import prisma from "../helpers/db/prisma.js";
import { maskPII } from "../utils/file/piiUtility.js";
import { readFileContent } from "../utils/file/fileUtility.js";
import { generateStructuredResponse } from "../helpers/llm/gemini.js";
import { fetchKeyFilesFromRepo } from "../helpers/github/github.js";
import {
    createCvExtractionPrompt,
    createCvEvaluationPrompt,
    createProjectEvaluationPrompt,
    createFinalSummaryPrompt,
} from "../utils/prompt/prompt.js";

/**
 * Extracts structured data from a CV text using a detailed prompt and a structured response generator.
 *
 * @async
 * @function extractCvData
 * @param {string} cvText - The text content of the CV to be processed.
 * @returns {Promise<Object>} A promise that resolves to the extracted structured data in JSON format.
 */
export const extractCvData = async (cvText) => {
    const prompt = createCvExtractionPrompt(cvText);

    const extractedData = await generateStructuredResponse(prompt, {
        temperature: 0.1,
    });

    return extractedData;
};

/**
 * Evaluates the match between a structured CV and a job description.
 *
 * This function retrieves evaluation rubrics from the database, generates a prompt
 * using the provided CV and job description, and then evaluates the match using
 * a structured response generator.
 *
 * @async
 * @function evaluateCvMatch
 * @param {Object} structuredCv - The structured CV data to be evaluated.
 * @param {Object} jobDescription - The job description to evaluate the CV against.
 * @returns {Promise<Object>} The evaluation result as a structured response.
 * @throws {Error} If the evaluation rubrics cannot be retrieved from the database.
 */
export const evaluateCvMatch = async (structuredCv, jobDescription) => {
    const rubrics = await prisma.$queryRaw`
      SELECT content FROM vectorembeddings
      WHERE metadata->>'type' = 'cv_match_evaluation'
    `;

    if (!rubrics || rubrics.length === 0) {
        throw new Error(
            "Could not retrieve CV evaluation rubrics from the database."
        );
    }

    const prompt = createCvEvaluationPrompt(
        structuredCv,
        jobDescription,
        rubrics
    );

    const evaluationResult = await generateStructuredResponse(prompt, {
        temperature: 0.2,
    });

    return evaluationResult;
};

/**
 * Evaluates a project based on the provided project report content and study case brief content.
 *
 * @async
 * @function evaluateProject
 * @param {string} projectReportContent - The content of the project report, which may include a GitHub URL.
 * @param {string} studyCaseBriefContent - The content of the study case brief.
 * @returns {Promise<Object>} The evaluation result generated by the LLM.
 * @throws {Error} If the project evaluation rubrics cannot be retrieved from the database.
 *
 * @description
 * This function performs the following steps:
 * 1. **Retrieval (Rubrics Context):** Fetches the project evaluation rubrics from the database.
 * 2. **Retrieval (Code Context):** Extracts the GitHub URL from the project report content (if available) and fetches key files from the repository.
 * 3. **Augmentation:** Constructs a prompt using the project report content, study case brief content, rubrics, and code context.
 * 4. **Generation:** Calls a language model (LLM) to generate a structured evaluation response.
 */
export const evaluateProject = async (
    projectReportContent,
    studyCaseBriefContent
) => {
    const rubrics = await prisma.$queryRaw`
      SELECT content FROM vectorembeddings
      WHERE metadata->>'type' = 'project_deliverable_evaluation'
    `;
    if (!rubrics || rubrics.length === 0) {
        throw new Error(
            "Could not retrieve Project evaluation rubrics from the database."
        );
    }

    let codeContext = "";
    const githubUrlMatch = projectReportContent.match(/github\.com\/[^\s]+/);
    if (githubUrlMatch) {
        codeContext = await fetchKeyFilesFromRepo(githubUrlMatch[0]);
    }

    const prompt = createProjectEvaluationPrompt(
        projectReportContent,
        studyCaseBriefContent,
        rubrics,
        codeContext
    );

    const evaluationResult = await generateStructuredResponse(prompt, {
        temperature: 0.2,
    });

    return evaluationResult;
};

/**
 * Refines and verifies evaluation results for CV and project, generates concise summaries,
 * and compiles the final output according to the API contract.
 *
 * @async
 * @function refineAndVerify
 * @param {Object} cvEvaluationResult - The evaluation result of the CV.
 * @param {number} cvEvaluationResult.weighted_average_score - The weighted average score of the CV evaluation.
 * @param {string} cvEvaluationResult.feedback - Detailed feedback from the CV evaluation.
 * @param {Object} projectEvaluationResult - The evaluation result of the project.
 * @param {number} projectEvaluationResult.weighted_average_score - The weighted average score of the project evaluation.
 * @param {string} projectEvaluationResult.feedback - Detailed feedback from the project evaluation.
 * @returns {Promise<Object>} The refined and verified results.
 * @returns {number} return.cv_match_rate - The final CV match rate (scaled score).
 * @returns {string} return.cv_feedback - Concise feedback for the CV.
 * @returns {number} return.project_score - The final project score (scaled score).
 * @returns {string} return.project_feedback - Concise feedback for the project.
 * @returns {string} return.overall_summary - A concise overall summary.
 */
export const refineAndVerify = async (
    cvEvaluationResult,
    projectEvaluationResult
) => {
    const rawCvScore = cvEvaluationResult.weighted_average_score; // example: 4.3
    const rawProjectScore = projectEvaluationResult.weighted_average_score; // example: 4.75

    const finalCvMatchRate = (rawCvScore * 20) / 100; // (4.3 * 20) / 100 = 0.86
    const finalProjectScore = rawProjectScore * 2; // 4.75 * 2 = 9.5

    const prompt = createFinalSummaryPrompt(
        cvEvaluationResult.feedback,
        projectEvaluationResult.feedback
    );

    const conciseSummaries = await generateStructuredResponse(prompt, {
        temperature: 0.4,
    });

    return {
        cv_match_rate: finalCvMatchRate,
        cv_feedback: conciseSummaries.concise_cv_feedback,
        project_score: finalProjectScore,
        project_feedback: conciseSummaries.concise_project_feedback,
        overall_summary: conciseSummaries.final_summary,
    };
};

/**
 * Runs the evaluation pipeline for a given evaluation job.
 *
 * This function performs the following steps:
 * 1. Retrieves the evaluation job data from the database.
 * 2. Reads the content of all required files (CV, project report, study case brief).
 * 3. Anonymizes Personally Identifiable Information (PII) in the CV content.
 * 4. Executes a series of LLM (Large Language Model) chaining steps:
 *    - Extracts structured data from the CV.
 *    - Evaluates the CV's match with the job description.
 *    - Evaluates the project report against the study case brief.
 *    - Refines and verifies the results to produce a final summary.
 * 5. Formats the output according to the API contract.
 *
 * @async
 * @function runEvaluationPipeline
 * @param {string} evaluationJobId - The ID of the evaluation job to process.
 * @returns {Promise<Object>} The final evaluation result formatted as per the API contract.
 * @throws {Error} If the evaluation job is not found or any step in the pipeline fails.
 */
export const runEvaluationPipeline = async (evaluationJobId) => {
    const job = await prisma.evaluationJob.findUnique({
        where: { id: evaluationJobId },
        include: {
          jobPosting: {
            include: {
              studyCaseBriefFile: true,
              descriptionEmbedding: true
            }
          },
          cvFile: true,
          projectReportFile: true,
        },
      });    

    if (!job) throw new Error("Job not found!");

    const cvContent = await readFileContent(job.cvFile.storagePath);
    const projectReportContent = await readFileContent(
        job.projectReportFile.storagePath
    );
    const studyCaseBriefContent = await readFileContent(
        job.jobPosting.studyCaseBriefFile.storagePath
    );
    const jobDescription = job.jobPosting.descriptionEmbedding.content;

    const anonymizedCvContent = maskPII(cvContent);

    const structuredCv = await extractCvData(anonymizedCvContent);

    const cvEvaluation = await evaluateCvMatch(
        structuredCv,
        jobDescription
    );

    const projectEvaluation = await evaluateProject(
        projectReportContent,
        studyCaseBriefContent
    );

    const finalResult = await refineAndVerify(cvEvaluation, projectEvaluation);

    return finalResult;
};
